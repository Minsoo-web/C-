# Stack / Queue

## 01. 프린터

### 문제 원본 보기

https://programmers.co.kr/learn/courses/30/lessons/42587

### 문제 조건

1. 인쇄 대기 목록 배열이 주어진다. (2,1,3,4, ...)
2. 각 인쇄 대기 목록들은 우선 순위를 갖고 있다. 1 ~ 9
3. 현재 처리될 인쇄물의 우선 순위보다 더 큰 우선 순위가 대기 중이라면  
   현재 처리될 인쇄물을 맨 뒤로 보낸다.
4. 주어진 처리 목록에서 주어진 인덱스의 요소가 몇번째에 출력되는지를 리턴

### 접근 방법

많이 해메였다.  
처음 접근 방법은 이중 포문을 사용해서 반복에 반복을 통해 배열을 직접 수정해가면서 출력하는 건데 이는 치명적인 오류를 내포하고 있었다.

가장 문제 되는 것이 배열이 변하면서 index 도 변한다는 점인데 예를 들어보자

```js
var a = [1, 2, 3, 4];
for (let i = 0; i < a.length; i++) {
  //  ...
}
```

이런 배열이 주어졌을 때 첫번째 포문에서의 index 값은 i 일 것이며 1을 a 배열의 맨 뒤로 보냈을 경우

```js
var a = [1, 2, 3, 4];
for (let i = 0; i < a.length; i++) {
  // a = [2,3,4,1]
  // a[i] = 3;
}
```

이래서 비교를 못하고 건너 뛰는 요소들이 생겼으며 포문을 몇 번 반복해야 하는지에 대해서도 뚜렷한 답을 찾기 쉽지 않았다.

두 번째 접근 방법이 재귀 함수였다.
while 문을 사용할까도 생각했지만 뭔가 재귀가 조금 더 편하게 와 닿아서 재귀로 짜보았다.

그리고 두 번째 치명적인 오류가 바로 변경되는 index 및 중복되는 값인데  
만약 내가 주어진 index의 값을 따로 저장해서 비교하려고 해도  
똑같은 우선순위를 갖는 숫자라면 똑같이 인식할것이며 그 값이 그 값인지 아닌지 구별하기 쉽지 않다.

그래서 우선순위와 index 를 갖고 있는 객체로 만들어서 우선순위 비교 -> index요소 검증을 통해 답을 도출했다.

### 생각하기

짜여진 코드에 대해서는 별 불만이 크게 있진 않은데  
for문 에서 삽질한 거랑 처음부터 객체화해서 비교하지 않은점이 많이 아쉽다.
